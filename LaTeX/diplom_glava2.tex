\sectioncentered*{2. Алгоритмы решения задачи дискретного логарифмирования}
\addcontentsline{toc}{section}{2. Алгоритмы решения задачи дискретного логарифмирования}

\section*{2.1. В произвольной мультипликативной группе }
\addcontentsline{toc}{subsection}{2.1. В произвольной мультипликативной группе}

Разрешимости и решению задачи дискретного логарифмирования в произвольной конечной абелевой группе посвящена статья J. Buchmann, M. J. Jacobson и E. Teske \cite{lit_8}. В алгоритме используется таблица, состоящая из $O(\sqrt{|g|})$ пар элементов, и выполняется $O(\sqrt{|g|})$ умножений. Данный алгоритм медленный и не пригоден для практического использования. Для конкретных групп существуют свои, более эффективные, алгоритмы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{2.2. В кольце вычетов по простому модулю}
\addcontentsline{toc}{subsection}{2.2. В кольце вычетов по простому модулю}

Рассмотрим сравнение

\begin{equation}\label{dlog_formula}
a^x \equiv b\ (mod\ p)
\end{equation}

где $p$ — простое, $b$ не делится на $p$. Если $a$  является образующим элементом группы $ \mathbb{Z} / p\mathbb{Z} $ , то сравнение (\ref{dlog_formula}) имеет решение при любых $b$ . Такие числа $a$ называются ещё первообразными корнями, и их количество равно $\phi (p) = p - 1$, где $ \phi $ — функция Эйлера. Решение сравнения (\ref{dlog_formula}) можно находить по формуле:

\begin{equation}\label{dlog_solution_formula}
x \equiv \sum_{i=1}^{p=2}(1-a^i)^{-1}b^i\ (mod\ p)
\end{equation}
Однако, сложность вычисления по этой формуле хуже, чем сложность полного перебора.

Следующий алгоритм \cite{lit_3} имеет сложность $O(\sqrt{p} \cdot \log{p})$.
Алгоритм
\begin{enumerate}
\item Присвоить $H := [\sqrt{p}] + 1$
\item Вычислить  $c = a^H mod\ p$
\item Составить таблицу значений $c^u\ mod\ p$ для $1 \leq u \leq H$ и отсортировать её.
\item Составить таблицу значений $b \cdot a^v\ mod\ p$ для $0 \leq v\leq H $ и отсортировать её.
\item Найти общие элементы в таблицах. Для них $c^u \equiv b \cdot a^v\ (mod\ p)$ откуда $a^{H\cdot u-v} \equiv b\ (mod\ p) $
\item Выдать $H\cdot u -v$.
\end{enumerate}

Существует также множество других алгоритмов для решения задачи дискретного логарифмирования в поле вычетов \cite{lit_3}. Их принято разделять на экспоненциальные и субэкспоненциальные. Полиномиального алгоритма для решения этой задачи пока не найдено.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{2.3. Алгоритмы с экспоненциальной сложностью}
\addcontentsline{toc}{subsection}{2.3. Алгоритмы с экспоненциальной сложностью}

Алгоритм Гельфонда-Шенкса (алгоритм больших и малых шагов, baby-step giant-step) был предложен независимо советским математиком Александром Гельфондом в 1962 году и Дэниэлем Шенксом в 1972 году. Относится к методам встречи посередине. 
Идея алгоритма состоит в выборе оптимального соотношения времени и памяти, а именно в усовершенствованном поиске показателя степени.

Пусть задана циклическая группа $G$ порядка $n$, генератор группы $\alpha$ и некоторый элемент группы $\beta$. Задача сводится к нахождению целого числа $x$, для которого выполняется $\alpha^x = \beta \mod m$. 

Алгоритм Гельфонда — Шенкса основан на представлении $x$ в виде $x=i\cdot m-j$, где  $m=\left\lfloor {\sqrt {n}}\right\rfloor +1$, и переборе $1 \leq i \leq m$ и $0 \leq j \leq m$. Ограничение на $i$ и $j$ следует из того, что порядок группы не превосходит $m$, а значит указанные диапазоны достаточны для получения всех возможных из полуинтервала $\left[0;m\right)$. Такое представление равносильно равенству 

\begin{equation}\label{gshanks_formula}
\alpha ^ {im} = \beta\alpha^j
\end{equation}

Алгоритм предварительно вычисляет $\alpha ^{im}$ для разных значений $i$ и сохраняет их в структуре данных, позволяющей эффективный поиск, а затем перебирает всевозможные значения $j$ и проверяет, если $\beta \alpha ^{j}$ соответствует какому-то значению $i$. Таким образом находятся индексы $i$ и $j$, которые удовлетворяют соотношению (\ref{gshanks_formula}) и позволяют вычислить значение $x=i\cdot m-j$.

Алгоритму Гельфонда — Шенкса требуется $O(n)$ памяти. Возможно выбрать меньшее $m$ на первом шаге алгоритма, но это увеличивает время работы программы до $O(n/m)$.

\begin{figure}[h]	
	\begin{center}
		\includegraphics{MartinHellman}
		\caption{Мартин Хеллман}
	\end{center}
\end{figure}

Другим методом дискретного логарифмирования является алгоритм Сильвера-Полига-Хеллмана. Он работает, если известно разложение числа $p-1=\prod_{i=1}^{s}q_i^{\alpha_i}$ на простые множители. Сложность оценивается как $O(\sum_{i=1}^s \alpha_i(\log p + q_i))$ . Если множители, на которые раскладывается $p-1$, достаточно маленькие, то алгоритм чрезвычайно эффективен. Это необходимо учитывать в выборе параметров при разработке криптографических схем, основанных на вычислительной сложности дискретного логарифмирования, иначе схема будет ненадёжной. 

Для применения алгоритма Сильвера-Полига-Хеллмана необходимо знать разложение $p-1$ на множители. В общем случае задача факторизации — достаточно трудоёмкая, однако если делители числа — небольшие, то это число можно быстро разложить на множители даже методом последовательного деления. Таким образом, в тех случаях, когда эффективен алгоритм Сильвера-Полига-Хеллмана, необходимость факторизации не усложняет задачу. 

Ещё одним методом дискретного логарифмирования является $\rho$-метод Полларда, который был предложен Джоном Поллардом в 1978 году, основные идеи алгоритма похожи на $\rho$-алгоритм Полларда для факторизации чисел. Условием работы $\rho$-метода Полларда является простота порядка группы, порождённой основанием $a$ дискретного логарифма по модулю $p$.

Алгоритм имеет эвристическую оценку сложности $O(p^{\frac{1}{2}})$. По сравнению с другими методами дискретного логарифмирования $\rho$-метод Полларда является менее затратным как по отношению к вычислительным операциям, так и по отношению к затрачиваемой памяти. Например, при достаточно больших значениях числа $p$ данный алгоритм является вычислительно менее сложным, чем алгоритм COS и алгоритм Адлемана. С другой стороны, условие работы алгоритма накладывает серьёзные ограничения на его использование. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{2.4. Субэкспоненциальные алгоритмы}
\addcontentsline{toc}{subsection}{2.4. Субэкспоненциальные алгоритмы}

Данные алгоритмы имеют сложность, оцениваемую как  $O(\exp(c(\log p \log p \log p)^d))$ арифметических операций, где $c$ и $0 \leq d \leq 1$ — некоторые константы. Эффективность алгоритма во многом зависит от близости $c$ к 1 и $d$ — к $0$.

Алгоритм Адлемана \cite{lit_9} появился в 1979 году. Это был первый субэкспоненциальный алгоритм дискретного логарифмирования. На практике он всё же недостаточно эффективен. В этом алгоритме $d = \frac{1}{2}$.

Алгоритм COS  \cite{lit_3} был предложен в 1986 году математиками Копперсмитом (Don Coppersmith), Одлыжко (Andrew Odlyzko) и Шреппелем (Richard Schroeppel). В этом алгоритме константа $c=1$, $d=\frac{1}{2}$. В 1991 году с помощью этого метода было проведено логарифмирование по модулю $p \approx 10^{58}$. В 1997 году Вебер  [3] провел дискретное логарифмирование по модулю $p \approx 10^{85}$ с помощью некоторой версии данного алгоритма. Экспериментально показано, что при $p \leq 10^{90}$ алгоритм COS лучше решета числового поля.

Дискретное логарифмирование при помощи решета числового поля \cite{lit_3} было применено к дискретному логарифмированию позднее, чем к факторизации чисел. Первые идеи появились в 1990-х годах. Алгоритм, предложенный Д. Гордоном в 1993 году \cite{lit_3}, имел эвристическую сложность $O(\exp{3^{3/2}}(\log p \log p \log p)^{\frac{1}{3}})$, но оказался достаточно непрактичным. Позднее было предложено множество различных улучшений данного алгоритма. Было показано, что при $p \geq 10^{100}$ решето числового поля быстрее, чем COS \cite{lit_3}. Современные рекорды в дискретном логарифмировании получены именно с помощью этого метода.

Наилучшими параметрами в оценке сложности на данный момент является $c = (92 + 26\sqrt{13})^{1/3}/3 \approx 1,902$, $d = \frac{1}{3}$. 
Для чисел специального вида результат можно улучшить. В некоторых случаях можно построить алгоритм, для которого константы будут $c \approx 1,00475$, $d = \frac{2}{5}$. За счёт того, что константа $c$ достаточно близка
к 1, подобные алгоритмы могут обогнать алгоритм с $d =\frac{1}{3}$.

Другая возможность эффективного решения задачи вычисления дискретного логарифма связана с квантовыми вычислениями. Теоретически доказано, что с их помощью дискретный логарифм можно вычислить за полиномиальное время. В любом случае, если полиномиальный алгоритм вычисления дискретного логарифма будет реализован, это будет означать практическую непригодность криптосистем на его основе \cite{lit_3}.
